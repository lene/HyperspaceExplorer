<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>HyperspaceExplorer: FunctionParameterValueBase Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>FunctionParameterValueBase Class Reference<br>
<small>
[<a class="el" href="group__FunctionParameterGroup.html">FunctionParameterGroup</a>]</small>
</h1><!-- doxytag: class="FunctionParameterValueBase" -->Interface for a value of a function parameter. Inherited by a template class.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="FunctionParameter_8H-source.html">FunctionParameter.H</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for FunctionParameterValueBase:</div>
<div class="dynsection">
<p><center><img src="classFunctionParameterValueBase__inherit__graph.png" border="0" usemap="#FunctionParameterValueBase__inherit__map" alt="Inheritance graph"></center>
<map name="FunctionParameterValueBase__inherit__map">
<area shape="rect" href="classFunctionParameterValue.html" title="A value for a function parameter. Template depending on its type." alt="" coords="5,84,221,110"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classFunctionParameterValueBase-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="926882a10c75d392d8384757d8910e68"></a><!-- doxytag: member="FunctionParameterValueBase::setValue" ref="926882a10c75d392d8384757d8910e68" args="(const double &amp;)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParameterValueBase.html#926882a10c75d392d8384757d8910e68">setValue</a> (const double &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set a double parm <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c4df9f2381511249aaeeb458c4673875"></a><!-- doxytag: member="FunctionParameterValueBase::setValue" ref="c4df9f2381511249aaeeb458c4673875" args="(const unsigned &amp;)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParameterValueBase.html#c4df9f2381511249aaeeb458c4673875">setValue</a> (const unsigned &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set an unsigned parm <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="939fac5936cdc57c88e771b0de3d0c89"></a><!-- doxytag: member="FunctionParameterValueBase::setValue" ref="939fac5936cdc57c88e771b0de3d0c89" args="(const int &amp;)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParameterValueBase.html#939fac5936cdc57c88e771b0de3d0c89">setValue</a> (const int &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set an int parm <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="29950ca43cb1200a2197b2bca217aeaa"></a><!-- doxytag: member="FunctionParameterValueBase::setValue" ref="29950ca43cb1200a2197b2bca217aeaa" args="(const std::string &amp;)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParameterValueBase.html#29950ca43cb1200a2197b2bca217aeaa">setValue</a> (const std::string &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set a string parm <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4897962d597cbdb6e464a6fe2db57182"></a><!-- doxytag: member="FunctionParameterValueBase::setValue" ref="4897962d597cbdb6e464a6fe2db57182" args="(const char *)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setValue</b> (const char *)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3b3022bc134779596c38ac8f4afa9884"></a><!-- doxytag: member="FunctionParameterValueBase::operator double" ref="3b3022bc134779596c38ac8f4afa9884" args="()=0" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParameterValueBase.html#3b3022bc134779596c38ac8f4afa9884">operator double</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get a double parm <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1cf25f1b6bc62a4a81042a5d00aa7057"></a><!-- doxytag: member="FunctionParameterValueBase::operator unsigned" ref="1cf25f1b6bc62a4a81042a5d00aa7057" args="()=0" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParameterValueBase.html#1cf25f1b6bc62a4a81042a5d00aa7057">operator unsigned</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get an unsigned parm <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8863252ecd7d0b17c81fb3e78453029b"></a><!-- doxytag: member="FunctionParameterValueBase::operator int" ref="8863252ecd7d0b17c81fb3e78453029b" args="()=0" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParameterValueBase.html#8863252ecd7d0b17c81fb3e78453029b">operator int</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get an int parm <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="23b42bb6bca92628fbdb0a184938352b"></a><!-- doxytag: member="FunctionParameterValueBase::operator std::string" ref="23b42bb6bca92628fbdb0a184938352b" args="()=0" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParameterValueBase.html#23b42bb6bca92628fbdb0a184938352b">operator std::string</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set a string parm <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e6671c4b7548b72f3a68248e35201e7f"></a><!-- doxytag: member="FunctionParameterValueBase::toString" ref="e6671c4b7548b72f3a68248e35201e7f" args="()=0" -->
virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParameterValueBase.html#e6671c4b7548b72f3a68248e35201e7f">toString</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">string representation <br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFunctionParameterValueBase_1_1WrongParameterTypeException.html">WrongParameterTypeException</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Interface for a value of a function parameter. Inherited by a template class. 
<p>
A lot of fumbling has taken place to make this hierarchy work despite the limitations of the C++ language, and I'm still not sure everything is clean and works as it should.<p>
The objections of the classes based on <a class="el" href="classFunctionParameterValueBase.html" title="Interface for a value of a function parameter. Inherited by a template class.">FunctionParameterValueBase</a> and declared in this file are as follows:<ul>
<li>present a unified interface to get and set function parameters of any type</li><li>these parameters must know their own type</li><li>the parameters know their name, default value and optionally a longer description string</li></ul>
<p>
A parameter value is read by casting the parameter to the appropriate type. A parameter value is set by calling <a class="el" href="classFunctionParameterValueBase.html#926882a10c75d392d8384757d8910e68" title="set a double parm">setValue()</a>.<p>
Because C++ does not allow declaring STL containers of abstract types, <a class="el" href="classFunctionParameter.html" title="A parameter to a Function with a name, an optional description and a default.">FunctionParameter</a> must be a concrete type, and may not be a template. Therefore, I made <a class="el" href="classFunctionParameter.html" title="A parameter to a Function with a name, an optional description and a default.">FunctionParameter</a> contain a <a class="el" href="classFunctionParameterValue.html" title="A value for a function parameter. Template depending on its type.">FunctionParameterValue</a>, which is a template and implements the abstract <a class="el" href="classFunctionParameterValueBase.html" title="Interface for a value of a function parameter. Inherited by a template class.">FunctionParameterValueBase</a>.<p>
<a class="el" href="classFunctionParameterValueBase.html" title="Interface for a value of a function parameter. Inherited by a template class.">FunctionParameterValueBase</a> defines the (virtual, of course) interface a <a class="el" href="classFunctionParameterValue.html" title="A value for a function parameter. Template depending on its type.">FunctionParameterValue</a> implements. Because virtual functions can not be defined as templates, I have to define <a class="el" href="classFunctionParameterValueBase.html#926882a10c75d392d8384757d8910e68" title="set a double parm">setValue()</a> for every type that can be used as a function parameter, and I also have to declare all casting operators which will serve as accessor to the value.<p>
<a class="el" href="classFunctionParameterValueBase.html#926882a10c75d392d8384757d8910e68" title="set a double parm">setValue()</a> can be defined with an empty function body. It is defined in the derived class as a function template. The cast operators are declared abstract in the base class, with a no-operation implementation in the derived class template and a specialization for every type that the template will be instantiated for. The cast operators must also be declared in the <a class="el" href="classFunctionParameter.html" title="A parameter to a Function with a name, an optional description and a default.">FunctionParameter</a> class, which delegates them to the <a class="el" href="classFunctionParameterValue.html" title="A value for a function parameter. Template depending on its type.">FunctionParameterValue</a> object it holds. In that way, you can cast a <a class="el" href="classFunctionParameter.html" title="A parameter to a Function with a name, an optional description and a default.">FunctionParameter</a> object to a desired type, and thus get access to its value.<p>
Should I ever want to add another type of possible function parameter, I must declare a <a class="el" href="classFunctionParameterValueBase.html#926882a10c75d392d8384757d8910e68" title="set a double parm">setValue()</a> function for it in <a class="el" href="classFunctionParameterValueBase.html" title="Interface for a value of a function parameter. Inherited by a template class.">FunctionParameterValueBase</a>, and a cast operator in <a class="el" href="classFunctionParameterValueBase.html" title="Interface for a value of a function parameter. Inherited by a template class.">FunctionParameterValueBase</a>, <a class="el" href="classFunctionParameterValue.html" title="A value for a function parameter. Template depending on its type.">FunctionParameterValue</a> and <a class="el" href="classFunctionParameter.html" title="A parameter to a Function with a name, an optional description and a default.">FunctionParameter</a>. Then I must define a specialization for it in FunctionParameter.C. Man, what a pain in the ass!<p>
Finally, I had to declare a Factory to create <a class="el" href="classFunctionParameter.html" title="A parameter to a Function with a name, an optional description and a default.">FunctionParameter</a> objects depending on the type of its value in the class <a class="el" href="classParameterFac.html" title="Class with factory methods to create a FunctionParameter.">ParameterFac</a>. There are two ways to create a parameter:<ul>
<li>either when you want to declare it for a <a class="el" href="classFunction.html" title="A Function is a generalized four-dimensional mathematical function.">Function</a> (in the constructor of the concrete <a class="el" href="classFunction.html" title="A Function is a generalized four-dimensional mathematical function.">Function</a> object). Then you want to give it a default value. createParameterWithDefault() is the function for that.</li><li>or you want to pass a <a class="el" href="classFunctionParameter.html" title="A parameter to a Function with a name, an optional description and a default.">FunctionParameter</a> to a function to actually set the parameter. createParameterWithValue() does this.</li></ul>
<p>
If this elaborate construction of a type system for function parameters strikes you as needlessly complicated, thank the architects of the C++ language for it. (Just kidding. It makes perfect sense to forbid templated functions as virtual members, and I'm sure there is a good reason to forbid abstract classes as container contents. (I just don't see it now, but I did not think hard on it.) C++ is a very clever language) <hr>The documentation for this class was generated from the following file:<ul>
<li>HyperspaceExplorer/src/Functions/<a class="el" href="FunctionParameter_8H-source.html">FunctionParameter.H</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat May 31 15:28:00 2008 for HyperspaceExplorer by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
